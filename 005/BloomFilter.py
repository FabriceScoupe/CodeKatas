#!/usr/bin/python

# Code Kata 5: Bloom Filters
# ==========================
# set of n strings: using m (multiple of n) bits, and k hash functions
# whose domain is [0..m-1]
# For each Sn of n set bit at index Hk(Sn) to 1

import md5
from random import randint
import array # Efficient array

def get_hashes(w, m, k):
     md5_hash = md5.md5(w)
     h = int(md5_hash.hexdigest(), 16)
     hks = []
     for i in xrange(k):
         hks += [h % m]
         h /= m
         if not h: 
             md5_hash.update(w)
             h = int(md5_hash.hexdigest(), 16)
     #print "hashes(%s,%d,%d) = [%s]" % (w,m,k,", ".join([str(e) for e in hks]))
     return hks

def get_bloom_filter(word_list, m, k):
    mm = 8*((m + 7) / 8) # Get multiple of 8 >= m
    bitarray = array.array('B', (0 for i in xrange(mm / 8)))
    for w in word_list:
        for hk in get_hashes(w, mm, k): bitarray[hk / 8] |= (1 << (hk % 8))
    return bitarray

def check_bloom_filter(w, b, k):
    for hk in get_hashes(w, len(b)*8, k):
        if (b[hk / 8] & (1 << (hk % 8)) == 0): return False
    return True

chars = "".join([chr(i) for i in xrange(0x41,0x5B)]) + \
        "".join([chr(i) for i in xrange(0x61,0x7B)])

# Values generated by this function can be checked against:
# http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html
#
def test_false_positives(niters, words, m, k):
    bitset = get_bloom_filter(words, m, k)
    for w in words: assert(check_bloom_filter(w, bitset, k)) # Check
    fp = 0.0
    for i in xrange(1, niters):
        w = "$"+"".join([chars[randint(0, len(chars)-1)]
                            for j in xrange(randint(1, 10))])
        if (check_bloom_filter(w, bitset, k)):
            fp += 1
            #print "%s false positive (%d, %d)" % (w, i, fp)
    print "m/n = %d\tk = %d\t false positives = %.4f" % \
        (len(bitset)*8/len(words), k, fp/niters)

# Use /usr/share/dict/words
word_list = [l.rstrip('\n') for l in open("/usr/share/dict/words").readlines()]
print "Size of word list = %d" % len(word_list)

for r in xrange(2, 11):
    for k in xrange(1, r+1):
        test_false_positives(10000, word_list, r*len(word_list), k)
